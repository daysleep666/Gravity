---
layout: post
title:  "mysql基础06-例子"
date:   2020-01-16 22:00:00
categories: mysql
---

## EXAMPLE 1

### 当前表
id | num
---|---
1  | 1

事务ID100 | 事务ID101 | 事务ID102 |
-----|-----|-----|
1.START TRANSACTION WITH CONSISTENT SNAPSHOT|2.START TRANSACTION WITH CONSISTENT SNAPSHOT|3.START TRANSACTION WITH CONSISTENT SNAPSHOT|
-|-| 4.UPDATE table SET num = num + 1 WHERE id = 1|
5.UPDATE table SET num = num + 1 WHERE id = 1|-|-|
-|-|6.SELECT * FROM table WHERE id = 1|
-|-|7.COMMIT|
8.SELECT * FROM table WHERE id = 1|-|-|
9.COMMIT|-|-|
 -|10.SELECT * FROM table WHERE id = 1|-|
-| 11.COMMIT|-|

- 1,2,3步为开始事务并产生快照读
- 4.更新语句,写入undo-log记录一条回滚操作,修改当前行数据。(如果是主键列,还会标记当前行为删除,并插入新行)
- 5.因为行锁,会阻塞住,直到超时或者锁没了.会发起死锁检测
- 6.这行数据的版本号为当前版本,直接读取,查询结果为2
- 7.提交.解锁(两阶段锁结束).
- 8.步骤5执行的时候会先读到最新数据(当前读),num=2,在执行+1操作(重复4的步骤).步骤8查询的时候会发现数据的版本号为当前版本.所以结果是3
- 9.提交.解锁(两阶段锁结束).
- 10.数据num=3的版本低于当前版本,但处于事务活跃组里(事务启动的时候会记录当前全部活跃的事务ID),根据undo-log,找到上个版本数据num=2,数据的版本高于当前版本,也不可见,在找到上个版本的数据num=1,这时这条数据的版本低于当前版本,所以读到当前数据为1

## EXAMPLE 2

事务A | 事务B|
------|----|
begin | begin |
1.UPDATE table SET num = 1 WHERE id = 1 | -|
-|2.UPDATE table SET num = 1 WHERE id = 2 |
3.UPDATE table SET num = 1 WHERE id = 2|-|
-|4.UPDATE table SET num = 1 WHERE id = 1 | 

步骤3,4会产生死锁

死锁会在以下情况下解除:
1. 操作超时会自动退出
2. 发起死锁检测,检测到死锁后会退出

## EXAMPLE 3

UPDATE table SET num = 1;

两阶段提交
1. 产生redo-log处于prepare阶段
2. 产生undo-log
3. redo-log进入commit