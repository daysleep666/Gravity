---
layout: post
title:  "校验和"
date:   2018-11-04 15:22:54
categories: 基础知识
---

校验和计算方法:将字节以每十六位(两个字节)分成一组，然后反码求和，就是取反全部相加或者先相加在全部取反。【反码: 将其二进制每一位取反。动词。】[如果字节长度为奇数，则需要在最后补上一个字节0]

检验校验和的方法:依旧是将字节以每十六位(两个字节)分成一组，然后全部相加，最后的结果应该是FFFF，就说明结果是对的。

在求和的过程中，会产生进位，向十进制计算一样，低位向高位进位，但是需要注意的是，当高位产生进位，就需要将高位进位加到最低位上。
                            
一个求校验和的例子:

>从wireshark中找一个数据包，取其IP首部:45 00 00 1c c9 3d 00 00 40 01 b2 f4 0a 00 00 42 7b ce 78 9f
>IP首部的校验和:0xb2f4
>以十六位为单位分组:4500 001c c93d 0000 4001 0000 0a00 0042 7bce 789f，将校验和b2f4置为0x0000
>求和:4500+001c+c93d+0000+4001+0000+0a00+0042+7bce+789f=0x24D09
>将其高位进位加到最低位上:4D09+2=4d0b 
>取反:~0x4d0b=0xb2f4
>EA31就是我们计算出的校验和。

验证校验和的例子:

>依旧是上面这个首部:45 00 00 1c c9 3d 00 00 40 01 b2 f4 0a 00 00 42 7b ce 78 9f
>以十六位为单位分组:4500 001c c93d 0000 4001 b2f4 0a00 0042 7bce 789f
>求和:4500+001c+c93d+0000+4001+b2f4+0000+0a00+0042+7bce+789f=0xffff
>最后的结果是FFFF，就说明我们的数据是正确的。


-------------

### IP首部校验和

IP首部的校验和就是IP首部计算的校验和。

### TCP,UDP的的校验和

首部，伪首部和数据计算的校验和。

----

```

func main() {
	// 这是一个十六进制编码，需要先解码为十进制编码
	v, _ := hex.DecodeString("45000054bc770000400100000a00005d0a00ffff")	
	fmt.Println(CheckSum(v))
}

func CheckSum(data []byte) uint16 {
	var sum uint32
	i := 0
	for ; i < len(data); i += 2 {
		sum += uint32(data[i])<<8 + uint32(data[i+1]) 
		// 两个字节，前一个字节右移8位加上后一个字节，就是组成了一个32位的字节。因为一个字节是8位，所以要先转成长为32位的int，同时也是为了方便计算。
		//它们的和必须是32位以上，因为sum是一个累加值，累加结果可能会超过16位，发生溢出。
	}
	if i != len(data) {
		sum += uint32(data[i]) << 8 //如果是奇数需要在最后补0，加0省略
	}
	sum += sum >> 16    // 将超过十六位的部分加到最低位上。
	return uint16(^sum) // 取反
}

```